\chapter{Langage relationnel} % (fold)
\label{cha:langage_relationnel}


\section{Définitions} % (fold)
\label{sec:d_finitions}


\paragraph{Définition} % (fold)
\label{par:d_finition}

L'ensemble des langages rationnels $Rat(\Sigma)$ sur l'alphabet $\Sigma$ est le plus petit ensemble des langages satisfaisant les conditions :

\begin{itemize}
	\item $\varnothing$ est un langage rationnel.
	\item $\{\epsilon\}$ est un langage rationnel.
	\item $\forall a \in \Sigma$, a est un langage rationnel.
	\item Si $\mathcal{L}_1,\mathcal{L}_2 \in Rat(\Sigma)$ alors $\mathcal{L}_1 \cup \mathcal{L}_2 \in Rat(\Sigma)$.
	\item Si $\mathcal{L}_1,\mathcal{L}_2 \in Rat(\Sigma)$ alors $\mathcal{L}_1 . \mathcal{L}_2 \in Rat(\Sigma)$.
	\item Si $\mathcal{L} \in Rat(\Sigma)$ alors $\mathcal{L}^* \in Rat(\Sigma)$.
\end{itemize}

% paragraph d_finition (end)

$Rat(\Sigma)$ est le plus petit ensemble qui contient les langages finis, fermé par Union, Concaténation et Étoile de langages finis, s'appelle une décomposition de Kleene.

% section d_finitions (end)


\section{Expression régulière} % (fold)
\label{sec:expression_r_guli_re}

Les expressions régulières sont une manière plus simple d'écrire une décomposition de Kleene.


\paragraph{Définition} % (fold)
\label{par:d_finition}

Une expression régulière (ou expression rationnelle) pour un alphabet $\Sigma$ est une expression formé par les règles suivantes :

\begin{itemize}
	\item $\varnothing$ est une expression régulière.
	\item $\epsilon$ est une expression régulière.
	\item Si $a \in \Sigma$ alors $a$ est une expression régulière.
	\item Si $\alpha$ et $\beta$ sont des expressions régulières alors $\alpha + \beta$ est une expression régulière.
	\item Si $\alpha$ et $\beta$ sont des expressions régulières alors $\alpha . \beta$ est une expression régulière.
	\item Si $\alpha$ est une expression régulière alors $\alpha^*$ est une expression régulière.
\end{itemize}

% paragraph d_finition (end)


\paragraph{Définition} % (fold)
\label{par:d_finition}

On appelle valeur d'une expression régulière $\alpha$, notée $\mathcal{L}(\alpha)$ le langage désigné par l'expression régulière $\alpha$ définit par :

\begin{itemize}
	\item $\mathcal{L}(\varnothing)=\varnothing$.
	\item $\mathcal{L}(\epsilon)=\{\epsilon\}$.
	\item Si $a \in \Sigma, \mathcal{L}(a)=\{a\}$.
	\item Si $\alpha$ et $\beta$ sont des expressions régulières alors $\mathcal{L}(\alpha + \beta)=\mathcal{L}(\alpha) \cup \mathcal{L}(\beta)$.
	\item Si $\alpha$ et $\beta$ sont des expressions régulières alors $\mathcal{L}(\alpha * \beta)=\mathcal{L}(\alpha) . \mathcal{L}(\beta)$.
	\item Si $\alpha$ est une expression régulière alors $\mathcal{L}(\alpha^*)=(\mathcal{L}(\alpha))^*$.
\end{itemize}

% paragraph d_finition (end)


\paragraph{Exemples} % (fold)
\label{par:exemples}

\begin{itemize}
	\item $\mathcal{L}((ab + \epsilon)bb)=\{abbb , bb\}$.
	\item $\mathcal{L}((a + b)^*bb)$ sont tous les mots de l'alphabet $\Sigma$ se terminant par bb.
\end{itemize}

% paragraph exemples (end)


\paragraph{Attention} % (fold)
\label{par:attention}

$a$ peut désigner 3 choses différentes :
\begin{itemize}
	\item Le symbole $a$ de $\Sigma$.
	\item Le mot $a$ (une suite finie de un symbole).
	\item $a$ est maintenant une expression régulière (dont la valeur est un langage, soit un ensemble de mots $\mathcal{L}(a)=\{a\}$).
\end{itemize}
Il est donc important de préciser de quoi l'on parle au vue des notations.

% paragraph attention (end)


\paragraph{Proposition} % (fold)
\label{par:proposition}

Un langage est rationnelle si et seulement s'il est la valeur d'une expression régulière.

% paragraph proposition (end)


\paragraph{Preuve} % (fold)
\label{par:preuve}

Par isomorphisme (équivalences) des définitions inductives (on part du cas de base pour aller vers des cas généraux).\\

% paragraph preuve (end)

On autorise d'autres notations.

\begin{itemize}
	\item Si $\alpha$ est une expression régulière et $i \in \mathbb{N}$ alors $\alpha^i$ est une expression régulière, $\mathcal{L}(\alpha^i)=((\mathcal{L}(\alpha))^i$.\\
	Exemple : $\alpha=\alpha^3$.
	\item Si $\alpha$ est une expression régulière alors $\alpha^+$ est une expression régulière, $\mathcal{L}(\alpha^+)=(\mathcal{L}(\alpha))^+.$\\
	Exemple : $\alpha\alpha^*=\alpha^+$.
\end{itemize}


\paragraph{Définition} % (fold)
\label{par:d_finition}

2 expressions régulières $\alpha, \beta$ sont équivalentes, noté $\alpha = \beta$ si $\mathcal{L}(\alpha)=\mathcal{L}(\beta)$.

% paragraph d_finition (end)


\paragraph{Exemple} % (fold)
\label{par:exemple}

$(ab + \epsilon)bb=ab^3+b^2$.

% paragraph exemple (end)


Quelques égalités remarquables :

\begin{itemize}
	\item $\alpha + \beta = \beta + \alpha$.
	\item $\alpha + \alpha = \alpha$.
	\item $\alpha + \varnothing = \alpha$.
	\item $\alpha + (\beta + \gamma) = (\alpha + \beta) + \gamma$.
	\item $\alpha . \epsilon = \alpha$.
	\item $\alpha . \varnothing = \varnothing$.
	\item $\alpha . (\beta . \gamma) = (\alpha . \beta) . \gamma$.
	\item $\alpha . (\beta + \gamma) = \alpha . \beta + \alpha . \gamma$.
	\item $\alpha^* = \alpha^* . \alpha^* = ((\alpha^*)^*) = (\epsilon + \alpha)^* = \epsilon + \alpha^+$.
	\item $\varnothing^* = \epsilon^* = \epsilon$.
	\item $(\alpha + \beta)^* = (\alpha^* + \beta^*)^* = (\alpha^* . \beta^*)^* = \alpha^*(\beta . \alpha^*)^* = (\alpha^* . \beta)^* . \alpha^*$.
	\item $\alpha(\beta.\alpha)^* = (\alpha\beta)^*\alpha$.
\end{itemize}


Dans la suite du cours, on identifie $\alpha$ par $\mathcal{L}(\alpha)$.\\
$\alpha \subseteq \beta$ si $\mathcal{L}(\alpha) \subseteq \mathcal{L}(\beta)$. Grâce à la relation d'ordre, on peut obtenir les relations suivantes :


\begin{itemize}
	\item $\alpha \subseteq \beta$ et $\beta \subseteq \alpha$ implique $\alpha = \beta$.
	\item $\alpha \subseteq \alpha$.
	\item Si $\alpha \subseteq \beta$ alors, $\forall \gamma, \gamma\alpha \subseteq \gamma\beta$.
\end{itemize}


$\alpha = \beta$ si $\mathcal{L}(\alpha)=\mathcal{L}(\beta)$. Grâce à la relation d'équivalence, on peut obtenir les relations suivantes :


\begin{itemize}
	\item $\alpha = \alpha$.
	\item $\alpha = \beta$ implique $\beta = \alpha$.
	\item $\alpha = \beta$ et $\beta = \gamma$ implique $\alpha = \gamma$.
\end{itemize}


Si $L$ est le langage rationnel alors $L$ est une expression régulière, $\mathcal{L}(L)=L$.


\paragraph{Théorème} % (fold)
\label{par:th_or_me}

Soit $\alpha$ et $\beta$ 2 expressions régulières, ou langages relationnels, on considère l'équation d'inconnue $X$, $X = \alpha X + \beta$ ($X$ est un langage).


\begin{itemize}
	\item $\alpha^* \beta$ est solution de l'équation.
	\item $\alpha^* \beta$ est la plus petite solution.
	\item Si $\epsilon \not \in \alpha$ alors $\alpha^* \beta$ est l'unique solution.
\end{itemize}

% paragraph th_or_me (end)


\paragraph{Preuve} % (fold)
\label{par:preuve}

\begin{itemize}
	\item $\alpha^* \beta$ est solution de l'équation.\\

	On remplace $X$ par $\alpha^* \beta$ dans $\alpha X + \beta$.\\
	$\alpha X + \beta = \alpha(\alpha^* \beta) + \beta = \alpha^+ \beta + \beta = (\alpha^+ + \epsilon)\beta = \alpha^* \beta=X$.\\
	
	\item $\alpha^* \beta$ est la plus petite solution.\\
	Soit $X$ une solution, on veut montrer $\alpha^* \beta \subseteq X$.\\
	$\alpha^* \beta = (\sum\limits_{i \in \mathbb{N}} \alpha^i)\beta = \sum\limits_{i \in \mathbb{N}}(\alpha^i \beta)$.\\
	On montre par récurrence sur $i$ que $\forall i \in \mathbb{N}, \alpha^i\beta \subseteq X$ :
	
	\begin{itemize}
		\item Pour $i=0, \alpha^i \beta = \alpha^0 \beta = \epsilon \beta = \beta, \beta \subseteq \alpha X + \beta = X$.
		\item Pour $i+1$, on suppose que $\alpha^i \beta \subseteq X$.\\
		$\alpha^{i+1} \beta = \alpha \alpha^i \beta$ donc $\alpha^{i+1} \beta \subseteq \alpha X \subseteq \alpha X + \beta = X$.\\
	\end{itemize}
	
	$\forall \in \mathbb{N}, \alpha^i \beta \subseteq X$. Donc $\alpha^* \beta \subseteq X$, $\alpha^* \beta$ est la plus petite solution.\\

	\item Si $\epsilon \not \in \alpha$ alors $\alpha^* \beta$ est l'unique solution.\\

	Soit $X$ une solution, on va montrer $X \subseteq \alpha^* \beta$.\\
	$X = \alpha X + \beta$\\
	$X = \alpha(\alpha X + \beta)+\beta = \alpha^2 X + \alpha \beta + \beta$\\
	$X = \alpha^2(\alpha X + \beta) + \alpha \beta + \beta = \alpha^3 X + \alpha^2 \beta + \alpha^1 \beta + \alpha^0 \beta$\\
	$X = \alpha^{k+1} X + \alpha^k \beta + ... + \alpha^1 \beta + \alpha^0 \beta = \alpha^{k+1} X + (\alpha^k + ... + \alpha^1 + \alpha^0) \beta$.\\

	Soit $m \in X (m \in \mathcal{L}(X))$, soit $k = \left|m\right|$. Comme $\epsilon \not \in \alpha$, tous les mots de $\alpha^{k+1}$ sont de longueur supérieur ou égale à $k+1$, et donc tous les mots de $\alpha^{k+1} X $ sont de longueur supérieur ou égale à $k+1$. Donc $m \not \in \alpha^{k+1} X$. Donc $m \in (\alpha^k + ... + \alpha^1 + \alpha^0)\beta \in \alpha^* \beta$. Donc $X \subseteq \alpha^* \beta$.\\
\end{itemize}

% paragraph preuve (end)


\paragraph{Théorème} % (fold)
\label{par:th_or_me}

La règle d'Arden, ou Lemme d'Arden, est la règle suivante : Soit $\alpha$ et $\beta$ 2 expressions régulières, ou langages relationnels, on considère l'équation d'inconnue $X$, $X = \alpha X + \beta$ ($X$ est un langage). Si $\epsilon \not \in \alpha$ alors $\alpha^* \beta$ est l'unique solution. Comme $\alpha$ et $\beta$ sont rationnelles, alors $\alpha^* \beta$ est rationnel.

% paragraph th_or_me (end)

Si $\epsilon \in \alpha$ alors la solution n'est pas unique.$\forall \gamma$, tel que $\beta \subseteq \gamma$, alors $\alpha^* \gamma$ est aussi une solution.


\paragraph{Preuve} % (fold)
\label{par:preuve}

$\alpha X + \beta = \alpha (\alpha^* \gamma) + \beta = \alpha^+ \gamma + \beta$\\
$\alpha X + \beta = \alpha^* \gamma + \beta$ (car $\epsilon \in \alpha$) $ = \alpha^* \gamma$ (car $\beta \subseteq \gamma$ dont $\beta \subseteq \alpha^* \gamma$) $= \alpha$.

% paragraph preuve (end)


\paragraph{Analogie avec l'algèbre} % (fold)
\label{par:analogie_avec_l_alg_bre}

Si $\epsilon \not \in \alpha$ alors $\alpha^* \beta$ est une unique solution.\\
$X = \alpha X + \beta \Leftrightarrow X - \alpha X = \beta \Leftrightarrow (1-\alpha) X = \beta \Leftrightarrow X = \frac{\beta}{1-\alpha}$.\\
On suppose que $\alpha \not = 1$, alors $X = (1 + \alpha + \alpha^2 + ... + \alpha^k + ... )\beta$ grâce aux développement limité de $\frac{1}{1-\alpha}$, quand $\alpha \rightarrow 0$.\\
$X = (1 + \alpha + \alpha^2 + ... + \alpha^k + ... )\beta \Leftrightarrow X = \alpha^* \beta$.

% paragraph analogie_avec_l_alg_bre (end)


\paragraph{Remarques} % (fold)
\label{par:remarques}

\begin{itemize}
	\item $X = \epsilon X + \beta \Leftrightarrow \beta \subseteq X$.
	\item $X = \varnothing X + \beta \Leftrightarrow X = \beta$.
\end{itemize}

% paragraph remarques (end)

On considère maintenant le système de n équations à n inconnues $X_1, X_2, ..., X_n$ :

\[
   \left \{
   \begin{array}{cccc}
  		X_{1} = L_{1,1} X_1 + L_{1,2} X_2 + ... + L_{1,n} X_n + L_1\\
    	X_{2} = L_{2,1} X_1 + L_{2,2} X_2 + ... + L_{2,n} X_n + L_2\\
		\vdots\\
    	X_{n} = L_{n,1} X_1 + L_{n,2} X_2 + ... + L_{n,n} X_n + L_n\\
   \end{array}
   \right .
\]

Où les $L_{i,j}$ et $L_i$ sont des langages rationnelles.

\paragraph{Définition} % (fold)
\label{par:d_finition}

Le système ci-dessus est régulier si $\forall i,j, \epsilon \not \in \mathcal{L}_(i,j)$.

% paragraph d_finition (end)


\paragraph{Théorème} % (fold)
\label{par:th_or_me}

Un système d'équations réguliers à n équations et n inconnues à une unique solution qui est un langage rationnel pour chaque inconnue.

% paragraph th_or_me (end)


\paragraph{Preuve} % (fold)
\label{par:preuve}

On peut résoudre le système par une méthode de pivot de Gauss, et on remarque qu'à chaque étape, le système régulier de la forme : $X_1 = (L_{1,1})^*\ (L_{1,2} X_2 + ... + L_{1,n} X_n + L_1)$. On remplace $X_1$ dans toutes les équations et l'on recommence ainsi pour chaque une des inconnues.

% paragraph preuve (end)


\paragraph{Exemple} % (fold)
\label{par:exemple}

Soit le système suivant, avec $a,b \not \in \epsilon$ :\\
\[
   \left \{
   \begin{array}{cc}
  		X = aX + vY + \epsilon\\
    	Y = bX + aY\\
   \end{array}
   \right .
\]

\[
   \left \{
   \begin{array}{cc}
  		X = aX + b(a^*bX) + \epsilon\\
    	Y = a^*bX\\
   \end{array}
   \right .
\]

\[
   \left \{
   \begin{array}{cc}
  		X = (a+ba^*b)X + \epsilon\\
    	Y = a^*bX\\
   \end{array}
   \right .
\]

\[
   \left \{
   \begin{array}{cc}
  		X = (a+ba^*b)^*\\
    	Y = a^*b(a+ba^*b)^*\\
   \end{array}
   \right .
\]

% paragraph exemple (end)

% section expression_r_guli_re (end)


\section{Grammaires régulières} % (fold)
\label{sec:grammaires_r_guli_res}

Toutes les règles de production de la forme $A \rightarrow w$ ou $A \rightarrow wB$ avec $A$ et $B$ des non terminaux et $w$ un mot sur l'alphabet terminal. Un langage est régulier s'il est engendré par une grammaire régulière.


\paragraph{Proposition} % (fold)
\label{par:proposition}

Tout langage fini est régulier.

% paragraph proposition (end)


\paragraph{Preuve} % (fold)
\label{par:preuve}

Soit $L = \{w_1, w_2, ... , w_n\}$, $L$ est engendré par une grammaire $G = (\Sigma , \{S\}, \{S \rightarrow w, S \rightarrow w_1 \mid w_2 \mid ... \mid w_n\},S)$.
Une grammaire linéaire gauche a des règles de productions de la forme, $A \rightarrow w$ ou $A \rightarrow Bw$. On a une équivalence avec les grammaires régulières est le terme du langage engendré.

% paragraph preuve (end)


\paragraph{Proposition} % (fold)
\label{par:proposition}

Tout langage régulier est engendré par une grammaire $G=(\Sigma,N,P,S)$, dont les règles de productions sont toutes de la forme $A \rightarrow aB$ (avec $A,B \in N$, des non terminaux et $a \in \Sigma$, un terminal) ou $A \rightarrow \epsilon$, avec $A \in N$.

% paragraph proposition (end)


\paragraph{Preuve} % (fold)
\label{par:preuve}

Soit la grammaire régulière $G=(\Sigma,N,P,S)$. Soit une règle de $P$ qui n'a pas la bonne forme.

\begin{itemize}
	\item $A \rightarrow a_1a_2 ... a_k B$ avec $k \geq 2$.\\
	On ajoute k-1 non terminaux $B_1, B_2, ..., B_{k-1}$ à $N$, et on remplace la règle par k règles, on obtient : \\
	$A \rightarrow a_1 B_1$\\
	$B_1 \rightarrow a_2 B_2$\\
	$\vdots$\\
	$B_{k-1} \rightarrow a_k B$

	\item $A \rightarrow a_1a_2 ... a_k$ avec $k \geq 1$. On ajoute k non terminaux $B_1 B_2 ... B_k$ à $N$ et on remplace par les $k+1$ règles, on obtient :\\
	$A \rightarrow a_1 B_1$\\
	$B_1 \rightarrow a_2 B_2$\\
	$\vdots$\\
	$B_{k-1} \rightarrow a_k B_k$\\
	$B_k \rightarrow \epsilon$

	\item $A \rightarrow B$, avec $k=0$.
	\begin{itemize}
		\item Si $A = B$, alors on a la règle $A \rightarrow A$ que l'on peut supprimer.
		\item Si $A \not = B$. Soit $B \rightarrow \alpha_1 \mid \alpha_2 \mid ... \mid \alpha_n$, toutes les règles avec $B$ à gauche. On remplace $A \rightarrow B$ par $A \rightarrow \alpha_1 \mid \alpha_2 \mid ... \mid \alpha_n$.
	\end{itemize}

\end{itemize}

% paragraph preuve (end)


\paragraph{Remarque} % (fold)
\label{par:remarque}

Pour une grammaire régulière, on obtient l'arbre de dérivation suivant :

\begin{center}
	\begin{tikzpicture}[level distance=11mm,sibling distance=20mm]
	
	\node{S}
		child{node{$a_{1,1}$}}
		child{node{$a_{1,2}$}}
		child{node{...}}
		child{node{$a_{1,n}$}}
		child{node{$A_1$}
			child{node{$a_{2,1}$}}
			child{node{$a_{2,2}$}}
			child{node{...}}
			child{node{$A_2$}
				child{node{...}
					child{node{$A_k$}
						child{node{$a_{k,1}$}}
						child{node{$a_{k,2}$}}
						child{node{...}}
						child{node{$a_{k,n_k}$}}
						}
					}
				}
			}
		;

	\end{tikzpicture}
\end{center}

% paragraph remarque (end)


\paragraph{Remarques} % (fold)
\label{par:remarques}

Pour un arbre de dérivation il y a une seule dérivation qui lui correspond, c'est-à-dire que la dérivation gauche est équivalente à la dérivation droite.\\

% paragraph remarques (end)

Soit la grammaire $G=(\Sigma,N,P,S)$, soit $A \in N$, on peut définir $\mathcal{L}(A)=\{ w \in \Sigma^* \mid A \Rightarrow^* w \}$


\paragraph{Proposition} % (fold)
\label{par:proposition}

Soit $G=(\Sigma,N,P,S)$ une grammaire régulière alors $\forall A \in N, \mathcal{L}(A)$ est un langage régulière.

% paragraph proposition (end)


\paragraph{Preuve} % (fold)
\label{par:preuve}

$\mathcal{L}(A)$ est le langage engendré par $(\Sigma,N,P,A)$ avec $\Sigma,N,P$ les même que G.

% paragraph preuve (end)


% section grammaires_r_guli_res (end)


\section{Automate d'états fini} % (fold)
\label{sec:automate_d_tats_fini}

\paragraph{Définition} % (fold)
\label{par:d_finition}

Un automate d'états fini, ou automate fini, c'est un quintuplet $(\Sigma,Q,\Delta,D,F)$ avec:

\begin{itemize}
	\item $\Sigma$ est un alphabet, un ensemble fini de symboles.
	\item $Q$ est un ensemble fini d'états.
	\item $\Delta$ est un ensemble de relations, $\Delta \subseteq Q \times \Sigma \times Q$. Un élément $(q,x,q')$ de $\Delta$ est appelé une transition. On passe de l'état $q$ à l'état $q'$ en acceptant $x$.
	\item $D$ est l'ensemble des états initiaux, $D \subseteq Q$.
	\item $F$ est l'ensemble des états finaux, $F \subseteq Q$.
\end{itemize}

% paragraph d_finition (end)


\paragraph{Diagramme de transition} % (fold)
\label{par:diagramme_de_transition}

L'automate est vu comme un graphe orienté et étiqueté. On prendra par la suite les notations suivantes :

\begin{itemize}
	\item Un état $q \in Q$\\

	\begin{tikzpicture}
	  \tikzstyle{every state}=[draw=black,text=black]
	
	  \node[state] (Q)                    {$q$};
	
	\end{tikzpicture}\\

	\item Un état initial $q_0 \in D$\\

	\begin{tikzpicture}
	\tikzstyle{every state}=[draw=black,text=black]
	
		\node[initial,state]	(Q)	{$q_0$};
	
	\end{tikzpicture}\\

	\item Un état final $q_k \in F$\\

	\begin{tikzpicture}
	\tikzstyle{every state}=[draw=black,text=black]
	
		\node[state,accepting]	(Q)	{$q_k$};
	
	\end{tikzpicture}\\

	ou\\

	\begin{tikzpicture}[shorten >=1pt,node distance=2cm,>=stealth',thick]
	\tikzstyle{every state}=[draw=black,text=black]

		\node[state]	(Q)	{$q_k$};
		\coordinate[right of=Q] (dQ);
		\draw[->]	(Q)	to[bend right]	node[auto]	{}	(dQ);
	\end{tikzpicture}\\

	\item Une transition $(q,x,q') \in \Delta$\\

	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
	\tikzstyle{every state}=[draw=black,text=black]
	
		\node[state]	(1)						{$q_1$};
		\node[state]	(2)	[right of=1]		{$q_2$};

	\path	(1)	edge	node{$x$}	(2);
	
	\end{tikzpicture}\\

\end{itemize}

% paragraph diagramme_de_transition (end)


\paragraph{Exemple} % (fold)
\label{par:exemple}

Soit l'automate défini de la manière suivante $(\{a,b\},\{1,2\},\{(1,a,1),(1,b,2),(2,a,1)\},\{1\},\{1\})$\\

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
\tikzstyle{every state}=[draw=black,text=black]
	
	\node[state,initial,accepting]					(1)	{$1$};
	\node[state]					[right of=1]	(2)	{$2$};

	\path	(1)	edge	[loop above]	node{$a$}	(1)
				edge 	[bend left]		node{$b$}	(2)
			(2)	edge 	[bend left]		node{$a$}	(1);
			% (2)	edge					node($a$)	(1);

\end{tikzpicture}

% paragraph exemple (end)


\paragraph{Définition} % (fold)
\label{par:d_finition}

Soit l'automate $A=(\Sigma,Q,\Delta,D,F)$, soit $w$ un mot sur $\Sigma$ de longueur $k$ ($\left|w\right|=k$) et pour tout $i \leq k$, soit $x_i \in \Sigma$ tel que $w=x_1 x_2 \ldots x_k$.\\
Le mot est accepté, ou reconnu, par l'automate $A$, s'il existe une suite d'état $q_0, q_1, \ldots, q_k$ tel que:

\begin{itemize}
	\item $q_0 \in D$, l'état initial.
	\item $\forall i, 1 \leq i \leq k$, on a une transition de la forme $(q_{i-1},x,q_{i}) \in \Delta$.
	\item $q_k \in F$, l'état final.
\end{itemize}

% paragraph d_finition (end)


\paragraph{Exemple} % (fold)
\label{par:exemple}

Soit l'automate $A=(\{a,b\},\{1,2\},\{(1,a,1),(1,b,2),(2,a,1)\},\{1\},\{1\})$
\begin{itemize}
	\item $w=abaa$ est un mot accepté par l'automate.
	\item $w=abaab$ n'est pas un mot par l'automate.
\end{itemize}

% paragraph exemple (end)


\paragraph{Définition} % (fold)
\label{par:d_finition}

Soit $A=(\Sigma,Q,\Delta,D,F)$, le langage reconnu, ou accepté, par $A$, noté $\mathcal{L}(A)$ est $\mathcal{L}(A)=\{w \in \Sigma^* \mid w\ est\ reconnu\ par\ A\}$.

% paragraph d_finition (end)


\paragraph{Exemple} % (fold)
\label{par:exemple}

L'ensemble des mots tel que tout $b$ est suivi d'un $a$, est l'expression $(a+ba)^*$.

% paragraph exemple (end)


\paragraph{Définition} % (fold)
\label{par:d_finition}

Deux automates $A$ et $B$ sont équivalents si $\mathcal{L}(A)=\mathcal{L}(B)$.

% paragraph d_finition (end)


\paragraph{Définition} % (fold)
\label{par:d_finition}

Un langage $L \subseteq \Sigma^*$ est reconnaissable s'il existe un automate $A$ tel que $L=\mathcal{L}(A)$.

% paragraph d_finition (end)


\paragraph{Remarque} % (fold)
\label{par:remarque}

$\epsilon \in \mathcal{L}(A) \Leftrightarrow D \cap F \not = \varnothing$.

% paragraph remarque (end)


\paragraph{Définition} % (fold)
\label{par:d_finition}

$\forall q \in Q$, on note $\mathcal{L}(q)$, le langage reconnu par l'automate $A=(\Sigma,Q,\Delta,\{q\},F)$. Les $\mathcal{L}(q)$ sont des langages reconnaissables.

% paragraph d_finition (end)


\paragraph{Proposition} % (fold)
\label{par:proposition}

$\mathcal{L}(A) = \bigcup\limits_{q \in D} \mathcal{L}(q)$.

% paragraph proposition (end)


\paragraph{Preuve} % (fold)
\label{par:preuve}

Trivial par l'ensemble des définitions.

% paragraph preuve (end)


\paragraph{Définition} % (fold)
\label{par:d_finition}

Un automate $A$ est déterministes si :

\begin{itemize}
	\item $\left|D\right| = 1$, un seul état initial.
	\item Pour tout état, pour tout symbole, on a au plus une transition partant de cette état étiqueté par ce symbole. $\forall q \in Q, \forall x \in \Sigma, \left| \{ q' \in Q \mid (q,x,q') \in \Delta \} \right| \leq 1$.
\end{itemize}

C'est-à-dire que $\Delta$ est le graphe d'une fonction éventuellement partielle, de $Q \times \Sigma$ dans $Q$.\\

Un automate $A$ est complet si :

\begin{itemize}
	\item Pour tout état, pour tout symbole, on a au moins une transition partant de cette état étiqueté par ce symbole. $\forall q \in Q, \forall x \in \Sigma, \left| \{ q' \in Q \mid (q,x,q') \in \Delta \} \right| \geq 1$.\\
\end{itemize}

Un automate $A$ est déterministe complet si :

\begin{itemize}
	\item $\left| D \right| = 1$, un seul état initial.
	\item Pour tout état, pour tout symbole, on a une transition partant de cette état étiqueté par ce symbole. $\forall q \in Q, \forall x \in \Sigma, \left| \{ q' \in Q \mid (q,x,q') \in \Delta \} \right| = 1$.\\
\end{itemize}

Dans un automate déterministe complet, pour tout mot $w$, il existe un seul chemin étiqueté par $w$.

% paragraph d_finition (end)


\paragraph{Exemple} % (fold)
\label{par:exemple}

\begin{itemize}
	\item Soit l'automate $A = (\{a,b\} , \{1,2\} , \{(1,a,1) , (1,b,2) , (2,a,1)\} , \{1\} , \{1\})$ est déterministe mais non complet.
	\item Soit l'automate $A = (\{a,b\} , \{1,2\} , \{(1,a,1) , (1,a,2) , (2,b,1)\} , \{1\} , \{1\})$ est non déterministe et non complet.
\end{itemize}

\begin{center}
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
	\tikzstyle{every state}=[draw=black,text=black]
		
		\node[state,initial,accepting]					(1)	{$1$};
		\node[state]					[right of=1]	(2)	{$2$};
	
		\path	(1)	edge	[loop above]	node{$a$}	(1)
					edge 	[bend left]		node{$a$}	(2)
				(2)	edge 	[bend left]		node{$b$}	(1);
				% (2)	edge					node($a$)	(1);
	
	\end{tikzpicture}
\end{center}



% paragraph exemple (end)


\paragraph{Remarque} % (fold)
\label{par:remarque}

La relation de transition $\Delta \subseteq Q \times \Sigma \times Q$ peut être vue comme une fonction, notée $\Delta$, de $Q \times \Sigma \rightarrow \mathcal{P}(Q)$, avec $\mathcal{P}(Q)$ l'ensemble des parties de $Q$ noté aussi $\mathcal{L}^Q$.

% paragraph remarque (end)


\paragraph{Exemple} % (fold)
\label{par:exemple}

Soit l'automate $A = (\{a,b\} , \{1,2\} , \{(1,a,1) , (1,a,2) , (2,b,1)\} , \{1\} , \{1\})$, on a :\\

\begin{itemize}
	\item $\Delta(1,a) = \{1,2\}$.
	\item $\Delta(1,b) = \varnothing$.
	\item $\Delta(2,a) = \varnothing$.
	\item $\Delta(2,b) = \{1\}$.
\end{itemize}

% paragraph exemple (end)


\paragraph{Remarques} % (fold)
\label{par:remarques}

\begin{itemize}
	\item La fonction $\Delta$ peut être représenté par la table suivante :\\

	\begin{center}
		\begin{tabular}{|l|c|r|}
			\hline
			$\Delta$ & $a$ & $b$\\

			\hline
			1 & $\{1,2\}$ & $\varnothing$\\

			\hline
			2 & $\varnothing$ & $\{1\}$\\

			\hline
		\end{tabular}
	\end{center}
	
	\item Cette fonction de transition $\Delta : Q \times \Sigma \rightarrow \mathcal{P}(Q)$ peut être étendue à une fonction, notée $\Delta$ de $Q \times \Sigma^*$ dans $\mathcal{P}(Q)$, de la manière suivante :

	\begin{itemize}
		\item $\forall q \in Q, \Delta(q,\epsilon) = \{q\}$.
		\item $\forall q \in Q, \forall x \in \Sigma, \forall w \in \Sigma^*, \Delta(q,xw) = \bigcup\limits_{q' \in \Delta(q,x)} \Delta(q',w)$.
	\end{itemize}

\end{itemize}

% paragraph remarques (end)


\paragraph{Preuve} % (fold)
\label{par:preuve}

C'est bien une extension car \\$\forall q \in Q, \forall x \in \Sigma, \Delta(q,x) = \bigcup\limits_{q' \in \Delta(q,x)} \Delta(q',\epsilon) = \bigcup\limits_{q' \in \Delta(q,x)} \{q'\} = \Delta(q,x)$.

% paragraph preuve (end)


\paragraph{Exemple} % (fold)
\label{par:exemple}

Soit l'automate $A = (\{a,b\} , \{1,2\} , \{(1,a,1) , (1,a,2) , (2,b,1)\} , \{1\} , \{1\})$, on a :\\

$\Delta(1,aba)=\Delta(1,ba) \cup \Delta(2,ba) =\varnothing \cup \Delta(1,a)=\Delta(1,\epsilon) \cup \Delta(2,\epsilon) = \{1\} \cup \{2\} = \{1,2\}$.\\

% paragraph exemple (end)


\paragraph{Remarque} % (fold)
\label{par:remarque}

La fonction de transition $\Delta : Q \times \Sigma^* \rightarrow \mathcal{P}(Q)$ peut être étendu à une fonction, noté $\Delta$, de $\mathcal{P}(Q) \times \Sigma^*$ dans $\mathcal{P}(Q)$ de la manière suivante :\\

$\forall X \subseteq Q, \forall w \in \Sigma^*, \Delta(X,w) = \bigcup\limits_{q \in X}\Delta(q,w)$.

% paragraph remarque (end)


\paragraph{Proposition} % (fold)
\label{par:proposition}

Un mot $w \in \Sigma^*$ est accepté par $(\Sigma,Q,\Delta,D,F)$ si et seulement si $\Delta(D,w) \cap F \not = \varnothing$.

% paragraph proposition (end)


\paragraph{Preuve} % (fold)
\label{par:preuve}

On fait une récurrence sur la longueur du mot $w$. 

% paragraph preuve (end)


\paragraph{Conséquence} % (fold)
\label{par:cons_quence}

$\mathcal{L}(A) = \{ w \in \Sigma^* \mid \Delta(D,w) \cap F \not = \varnothing\}$.

% paragraph cons_quence (end)


\paragraph{Remarques} % (fold)
\label{par:remarques}

\begin{itemize}
	\item Si $A=(\Sigma,Q,\Delta,D,F)$ est déterministe alors à sa relation de transition correspond une fonction dont toutes les images sont des singletons ou $\varnothing$. A cette fonction, on peut faire correspondre une fonction $\delta : Q \times \Sigma \rightarrow Q$, définie par $\forall q \in Q, \forall x \in \Sigma$, s'il existe $q'$ tel que $(q,x,q') \in \Delta$ alors $q'$ est unique ($\Delta(q,x) = \{q'\}$) et $\delta(q,x)=q'$, s'il n'existe pas $q'$ alors $\delta(q,x)$ n'est pas défini ($\delta$ est une fonction partielle)($\Delta(q,x)=\varnothing$).

	\item Si $A$ est déterministe alors $D=\{q_0\}$, un seul état initial. L'automate $A$ pourra être désigné indifféremment par $(\Sigma,Q,\Delta,D,F)$, par définition de l'automate d'états fini, ou par le quintuplet $(\Sigma,Q,\delta,q_0,F)$, par définition de l'automate d'états finis déterministe.

	\item Si $A$ est déterministe complet alors $\delta$ est une fonction totale\\
	$\forall q \in Q, \forall x \in \Sigma, \delta(q,x)$ est défini.

	\item La fonction $\delta$ peut être étendu à $\delta : Q \times \Sigma^* \rightarrow Q$, si $A$ est complet, cette extension de $\delta$ est totale.
\end{itemize}

% paragraph remarques (end)


\paragraph{Proposition} % (fold)
\label{par:proposition}

Un mot de $w \in \Sigma^*$ est accepté par $A=(\Sigma,Q,\delta,q_0,F)$ déterministe si et seulement si $\delta(q_0,w) \in F$.

% paragraph proposition (end)


\paragraph{Preuve} % (fold)
\label{par:preuve}

Évidant en appliquant les définitions.

% paragraph preuve (end)


\paragraph{Proposition} % (fold)
\label{par:proposition}

Tout automate est équivalent à un automate complet.

% paragraph proposition (end)


\paragraph{Preuve} % (fold)
\label{par:preuve}

Soit $A=(\Sigma,Q,\Delta,D,F)$, un automate quelconque. Si $A$ est non complet :

\begin{itemize}
	\item On ajoute un nouvel état $\Pi$ à $Q$.
	\item $\forall q \in Q, \forall x \in \Sigma$, si $\Delta(q,x)=\varnothing$, alors on ajoute $(q,x,\Pi)$ à $\Delta$.
	\item $\forall x \in \Sigma$, on ajoute $(\Pi,x,\Pi)$ à $\Delta$.
\end{itemize}

L'automate obtenu $(\Sigma , Q \cup \{\Pi\} , \Delta \cup \{ (q,x,\Pi) \mid \Delta(q,x) = \varnothing \} \cup \{ (\Pi,x,\Pi) \mid x \in \Sigma \} , D , F)$ est complet et équivalent à $A$. Tous les nouveaux chemins se retrouvent dans l'état $\Pi$. L'état $\Pi$, qui est ajouté pour compléter l'automate, est puits, ou l'état poubelle.

% paragraph preuve (end)


\paragraph{Proposition} % (fold)
\label{par:proposition}

Tout automate est équivalent à un automate déterministe.

% paragraph proposition (end)


\paragraph{Preuve} % (fold)
\label{par:preuve}

Soit l'automate $A=(\Sigma,Q,\Delta,D,F)$. L'algorithme pour construire un automate déterministe équivalent noté $Det(A)$ est le suivant : \\
$Det(A) = (\Sigma , \mathcal{P}(Q) , \delta , D , \{X \in \mathcal{P}(Q) \mid X \cap F \not = \varnothing\} )$ avec $\delta$ défini par : $\forall X \in \mathcal{P}(Q), \forall x \in \Sigma, \delta(X,x)=\Delta(X,x)=\bigcup\limits_{q \in X} \Delta(q,x)$.

% paragraph preuve (end)


\paragraph{Idée de construction} % (fold)
\label{par:id_e_de_construction}

Partir de $D$. On suit en parallèle tous les chemins possibles dans $A$, donc à chaque instant on se trouve dans un ensemble d'états.

% paragraph id_e_de_construction (end)


\paragraph{Exemple} % (fold)
\label{par:exemple}

Soit l'automate $A = (\{a,b\} , \{1,2\} , \{(1,a,1) , (1,a,2) , (2,b,1)\} , \{1\} , \{1\})$, on peut faire la construction suivante :\\
$Det(A) = (\{a,b\} , \{\varnothing , \{1\} , \{2\} , \{1,2\}\} , \{ (\varnothing,a,\varnothing) , (\varnothing,b,\varnothing) , (\{1\},a,\{1,2\}) , (\{1\},b,\varnothing) ,(\{1,2\},a,\{1,2\}) , \linebreak[4] (\{1,2\},b,\{1\}) , (\{2\},a,\varnothing) , (\{2\},b,\{1\}) \} , \{1\} , \{ \{1\}  , \{1,2\} \} )$


\begin{table}[h!]
\begin{minipage}[t]{.6\linewidth}

	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
	\tikzstyle{every state}=[draw=black,text=black]
		
		\node[state,initial,accepting]					(1)	{$1$};
		\node[state]					[right of=1]	(2)	{$2$};
	
		\path	(1)	edge	[loop above]	node{$a$}	(1)
					edge 	[bend left]		node{$a$}	(2)
				(2)	edge 	[bend left]		node{$b$}	(1);
	
	\end{tikzpicture}

\end{minipage}
\begin{minipage}[t]{.6\linewidth}

	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
	\tikzstyle{every state}=[draw=black,text=black]
		
		\node[state,initial,accepting]	(A)							{$1$};
		\node[state,accepting]			(B)	[right of=A]			{$1,2$};
		\node[state]					(C)	[above right of=A]		{$\varnothing$};
		% \node[state,initial,accepting]					(1)	{$1$};
		% \node[state]					[right of=1]	(2)	{$2$};
	
		\path	(A)		edge					node{$b$}	(C)
						edge 	[bend left]		node{$a$}	(B)
				(B)		edge	[loop above]	node{$a$}	(B)
						edge 	[bend left]		node{$b$}	(A)
				(C)		edge	[loop right]	node{$a$}	(C)
						edge 	[loop left] 	node{$b$}	(C);
	
	\end{tikzpicture}

\end{minipage}
\end{table}

% paragraph exemple (end)

Tout langage reconnaissable est reconnu par un automate déterministe. L'automate déterministe est non unique, mais il existe un plus petit automate, nommé automate minimal.

\begin{center}
	\begin{tabular}{ | l | p{5cm} | p{5cm} |}
		\hline
		Comparaison & Automate non déterministe & Automate déterministe\\
		\hline
		Taille & Éventuellement le plus petit & \\
		\hline
		Algorithme & Exploration de tous les chemins possibles(Utilisation du back) & Plus intéressant car il y a 0 ou 1 chemin possible\\
		\hline
	\end{tabular}
\end{center}


\paragraph{Simplification du schéma des automates} % (fold)
\label{par:simplification_du_sch_ma_des_automates}

\begin{itemize}
	\item On peut remplacer l'ensemble des arcs de $q$ à $q'$ par un arc étiqueté, soit $\{ x\in \Sigma \mid (q,x,q') \in \Delta \}$\\\\
	Exemple:\\\\
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
	\tikzstyle{every state}=[draw=black,text=black]
	
		\node[state]	(1)						{$q$};
		\node[state]	(2)	[right of=1]		{$q'$};

	\path	(1)	edge	node{$\{a,b\}$}	(2);
	
	\end{tikzpicture}\\

	\item Dans les automates asynchrones, ou les automates avec des $\epsilon$-transition, on autorise les transitions étiquetées par $\epsilon$, soit $(q,\epsilon,q') \in \Delta$.

	\item On peut autoriser les transitions étiquetées par des mots.\\\\
	Exemple:\\\\
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm]
	\tikzstyle{every state}=[draw=black,text=black]
	
		\node[state]	(1)						{$q$};
		\node[state]	(2)	[right of=1]		{$q'$};

	\path	(1)	edge	node{$x_1x_2\ldots x_n$}	(2);
	
	\end{tikzpicture}\\

	Pour exprimer l'automate suivant :

	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
	\tikzstyle{every state}=[draw=black,text=black]
	
		\node[state]	(1)							{$q$};
		\node[state]	(2)	[right of=1]			{$q_1$};
		\node[state]	(3)	[right of=2]			{$q_2$};
		\node[state]	(4)	[right of=3,draw=white]	{$\ldots$};
		\node[state]	(5)	[right of=4]			{$q_{n-1}$};
		\node[state]	(6)	[right of=5]			{$q'$};


		\path	(1)	edge	node{$x_1$}				(2);
		\path	(2)	edge	node{$x_2$}				(3);
		\path	(3)	edge	node{$x_3$}				(4);
		\path	(4)	edge	node{$x_{n-1}$}			(5);
		\path	(5)	edge	node{$x_n$}				(6);
	
	\end{tikzpicture}\\

	\item On peut autoriser les transitions étiquetées par des expressions rationnelles. Attention, il y a un automate complet derrière l'expression régulières.\\\\

	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
	\tikzstyle{every state}=[draw=black,text=black]
	
		\node[state]	(1)							{$q$};
		\node[state]	(2)	[right of=1]			{$q'$};


		\path	(1)	edge	node{$(a+ab)^*$}		(2);
	
	\end{tikzpicture}\\

\end{itemize}

% paragraph simplification_du_sch_ma_des_automates (end)


% section automate_d_tats_fini (end)


\section{Équivalence des formalismes} % (fold)
\label{sec:_quivalence_des_formalismes}


\paragraph{Théorème de Kleene} % (fold)
\label{par:th_or_me_de_kleene}

Soit un langage $\mathcal{L}$, on a :

\begin{enumerate}
	\item $\mathcal{L}$ est un langage rationnel, il a une valeur d'expression régulière.
	\item $\mathcal{L}$ est un langage régulier, il engendre une grammaire régulière.
	\item $\mathcal{L}$ est un langage reconnaissable, il est reconnu par un automate fini, ou un automate déterministe.
\end{enumerate}

% paragraph th_or_me_de_kleene (end)


\paragraph{Preuve} % (fold)
\label{par:preuve}

\begin{itemize}
	\item $(2) \Rightarrow (1)$ : Soit une grammaire régulière $G=(\Sigma,N,P,S)$. On a vu qu'à la grammaire $G$, on peut faire correspondre une autre grammaire régulière $G'=(\Sigma,N',P',S')$ où toutes les règles sont de la forme :
	\begin{itemize}
		\item $X \rightarrow xY$ avec $X,Y \in N$ et $x \in \Sigma$
		\item $X \rightarrow \epsilon$\\
	\end{itemize}

	On a donc $\mathcal{L}(G) = \mathcal{L}(G')$ et on associe à $G'$ un système d'équations régulières, où le système à une unique solution, vu que $\epsilon \not \in \mathcal{L}$. Pour tout $Y \in N'$, si :
	\begin{itemize}
		\item $X \rightarrow a_1X_1 \mid a_2X_2 \mid \ldots \mid a_nX_n \mid \epsilon$, l'ensemble des productions avec X à gauche, on obtient l'équation suivante : $X = a_1X_1 + a_2X_2 + \ldots + a_nX_n + \epsilon$.
		\item $X \rightarrow a_1X_1 \mid a_2X_2 \mid \ldots \mid a_nX_n$, on obtient après simplification : $X = a_1X_1 + a_2X_2 + \ldots + a_nX_n$.\\
	\end{itemize}
	L'ensemble de toutes ces équations forme un système régulier. Donc le système a une unique solution et la valeur de $S'$ est une expression rationnelle du langage engendré par $G$. On a donc le langage régulier $\Rightarrow$ langage rationnel.

	\paragraph{Exemple} % (fold)
	\label{par:exemple}
	Soit les règles de productions suivantes :\\
	$S \rightarrow aS \mid aX \mid \epsilon$\\
	$X \rightarrow bS$\\
	On obtient le système d'équation suivant :\\

	\[
	   \left \{
	   \begin{array}{cc}
	  		S = aS + aX + \epsilon\\
	    	X = bS\\
	   \end{array}
	   \right .
	\]

	\[
	   \left \{
	   \begin{array}{cc}
	  		S = aS + abS + \epsilon\\
	    	X = bS\\
	   \end{array}
	   \right .
	\]

	\[
	   \left \{
	   \begin{array}{cc}
	  		 S = (a+ab)S + \epsilon\\
	    	X = bS\\
	   \end{array}
	   \right .
	\]

	\[
	   \left \{
	   \begin{array}{cc}
	  		S = (a+ab)^*\epsilon\\
	    	X = b(a+ab)^*\\
	   \end{array}
	   \right .
	\]

	\[
	   \left \{
	   \begin{array}{cc}
	  		S = (a+ab)^*\\
	    	X = b(a+ab)^*\\
	   \end{array}
	   \right .
	\]
	% paragraph exemple (end)

	\item $(3) \Rightarrow (1)$ : On procède de la même manière que pour $(2) \Rightarrow (1)$. Soit un automate d'état fini $A=(\Sigma,Q,\Delta,D,F)$, on associe à $A$ le système d'équations régulier pour chaque $q \in Q$, on obtient :\\

	\begin{itemize}
		\item Si $q \in F$, on a : $\sum\limits_{(q,x,q') \in \Delta} x q' + \epsilon$.
		\item Si $q \not \in F$, on a : $\sum\limits_{(q,x,q') \in \Delta} x q'$.
	\end{itemize}

	L'ensemble forme un système régulier, vu que $\epsilon$ n'est dans aucun facteurs des inconnues, il y a une unique solution : $\sum\limits_{q \in D}q$ est une expression régulière du langage reconnu par $A$.

	\paragraph{Remarque} % (fold)
	\label{par:remarque}
	
	On trouve pour chaque $q \in Q$, une expression régulière dont la valeur est $\mathcal{L}(q)$. Donc on a langage reconnaissable $\Rightarrow$ langage rationnel.

	% paragraph remarque (end)

	\paragraph{Exemple} % (fold)
	\label{par:exemple}
	Soit l'automate suivant :\\

	\begin{center}

		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
		\tikzstyle{every state}=[draw=black,text=black]
			
			\node[state,initial,accepting]					(1)	{$q_0$};
			\node[state]					[right of=1]	(2)	{$q_1$};
		
			\path	(1)	edge	[loop above]	node{$a$}	(1)
						edge 	[bend left]		node{$a$}	(2)
					(2)	edge 	[bend left]		node{$b$}	(1);
		
		\end{tikzpicture}\\

	\end{center}

	On a le système d'équation suivant :\\

	\[
	   \left \{
	   \begin{array}{cc}
	  		q_0 = aq_0 + aq_1 + \epsilon\\
			q_1 = bq_0\\
	   \end{array}
	   \right .
	\]
	
	\[
	   \left \{
	   \begin{array}{cc}
	  		q_0 = aq_0 + abq_0 + \epsilon\\
			q_1 = bq_0\\
	   \end{array}
	   \right .
	\]

	\[
	   \left \{
	   \begin{array}{cc}
	  		q_0 = (a+ab)q_0 + \epsilon\\
			q_1 = bq_0\\
	   \end{array}
	   \right .
	\]

	\[
	   \left \{
	   \begin{array}{cc}
	  		q_0 = (a+ab)^*\\
			q_1 = b(a+ab)^*\\
	   \end{array}
	   \right .
	\]\\
	% paragraph exemple (end)


	\item $(2) \Rightarrow (3)$ : Soit une grammaire régulière $G=(\Sigma,N,P,S)$. On reprend la grammaire précédemment défini $G'$, pour la preuve $(2) \Rightarrow (1)$. On associe à $G'$, l'automate suivant : $A=(\Sigma , N' , \{(X,x,Y) \mid X\rightarrow xY \in P'\} , \{S'\} , \{X \mid X \rightarrow \epsilon \in P'\})$. On a $\mathcal{L}(A) = \mathcal{L}(G') = \mathcal{L}(G)$, donc on obtient le langage régulier $\Rightarrow$ le langage reconnaissable.

	\paragraph{Exemple} % (fold)
	\label{par:exemple}
	Soit les règles de productions suivantes :\\
	$S \rightarrow aS \mid aX \mid \epsilon$\\
	$X \rightarrow bS$\\\\
	On obtient l'automate suivant :\\
	\begin{center}

		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
		\tikzstyle{every state}=[draw=black,text=black]
			
			\node[state,initial,accepting]					(1)	{$S$};
			\node[state]					[right of=1]	(2)	{$X$};
		
			\path	(1)	edge	[loop above]	node{$a$}	(1)
						edge 	[bend left]		node{$a$}	(2)
					(2)	edge 	[bend left]		node{$b$}	(1);
		
		\end{tikzpicture}\\

	\end{center}

	% paragraph exemple (end)


	\item $(3) \Rightarrow (2)$ : Soit $A$ un automate, soit l'automate déterministe de $A$, tel que $Det(A) = (\Sigma,Q,\delta,q_0,F)$, on a la grammaire suivante : $G = (\Sigma , Q , \{q \rightarrow xq' \mid \delta(q,x) = q'\} \cup \{q \rightarrow \epsilon \mid q \in F\} , q_0)$. On a $\mathcal{L}(G)=\mathcal{L}(A)$, soit le langage régulier $\Rightarrow$ langage reconnaissable.

	\paragraph{Exemple} % (fold)
	\label{par:exemple}
	
	Soit l'automate suivant :

	\begin{center}

	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
	\tikzstyle{every state}=[draw=black,text=black]
		
		\node[state,initial,accepting]					(1)	{$q_0$};
		\node[state]					[right of=1]	(2)	{$q_1$};
	
		\path	(1)	edge	[loop above]	node{$a$}	(1)
					edge 	[bend left]		node{$a$}	(2)
				(2)	edge 	[bend left]		node{$b$}	(1);
	
	\end{tikzpicture}\\
	
	\end{center}

	On obtient les règles de productions suivantes :\\
	$q_0 \rightarrow aq_0 \mid aq_1 \mid \epsilon$\\
	$q_1 \rightarrow bq_0$\\
	Et donc on obtient la grammaire suivante : $G=(\{a,b\} , \{q_0,q_1\} , \{q_0 \rightarrow aq_0 \mid aq_1 \mid \epsilon , q_1 \rightarrow bq_0\} , \{q_0\})$\\

	% paragraph exemple (end)


	\item $(1) \Rightarrow (3)$ : D'après la définition du langage rationnel, on montre qu'à tout langage rationnel, on peut faire correspondre un automate :

	\begin{itemize}
		\item $\varnothing$ reconnu par l'automate $A=(\varnothing,\varnothing,\varnothing,\varnothing,\varnothing)$, qui est n'importe quel automate sans état final.
		\item $\epsilon$ reconnu par l'automate $A=(\Sigma, \{q\} , \varnothing ,\{q\} , \{q\})$.
		\item $\forall a \in \Sigma$, $a$ est reconnu par $A=(\Sigma , \{q_0,q_1\} , \{q_0,a,q_1\} , \{q_0\} , \{q_1\})$.
		\item Soit $\alpha_1$ et $\alpha_2$, deux expressions rationnelles, reconnu respectivement par $A_1=(\Sigma_1 , Q_1 , \Delta_1 , D_1 , F_1)$ et $A_2=(\Sigma_2 , Q_2 , \Delta_2 , D_2 , F_2)$. Pour simplifier, on suppose : $Q_1 \cap Q_2 = \varnothing$.
		\begin{itemize}
			\item $\alpha_1 + \alpha_2$ reconnue par $(\Sigma_1 \cup \Sigma_2 , Q_1 \cup Q_2 , \Delta_1 \cup \Delta_2 , D_1 \cup D_2 , F1 \cup F_2)$, on le note $A_1 + A_2$ (ou $A_1 \cup A_2$).
			\item $\alpha_1 \cdot \alpha_2$ reconnue par $(\Sigma_1 \cup \Sigma_2 , Q_1 \cup Q_2 , \Delta , D_1 , F)$, on le note $A_1 \cdot A_2$, avec $\Delta$ :\\
			\[
				\left \{
				\begin{array}{cc}
					(q,x,q') \in \Delta_1 \cup \Delta_2 \Rightarrow (q,x,q') \in \Delta\\
					q_1 \in F_1 , q' \in D_2 , (q',x,q'') \in D_2 \Rightarrow (q,x,q'') \in \Delta\\
				\end{array}
				\right .
			\]
			Tout état final de $A_1$ joue le même rôle que tout état initial de $A_2$. $F$ est défini par :\\
			\[
				\left \{
				\begin{array}{cc}
					D_2 \cap F_2 = \varnothing \Rightarrow F=F_2\\
					D_2 \cap F_2 \not = \varnothing \Rightarrow F=F_1 \cup F_2\\
				\end{array}
				\right .
			\]
			\item $\alpha_1^*$, noté $A^*$, reconnue par $(\Sigma_1 , Q_1 \cup \{q_0\} , \Delta , \{q_0\} , F \cup \{q_0\})$, où $q_0$ est un nouvel état et $\Delta$ défini par :
			\[
				\left \{
				\begin{array}{ccc}
					(q,x,q') \in \Delta_1 \Rightarrow (q,x,q') \in \Delta\\
					q \in D_1\ et\ (q,x,q') \in \Delta_1 \Rightarrow (q_0,x,q') \in \Delta\\
					q \in D_1,\ q''\in F_1,\ (q,x,q') \in \Delta_1 \Rightarrow (q'',x,q') \in \Delta\\
				\end{array}
				\right .
			\]			
		\end{itemize}
	\end{itemize}

	On peut supprimer les états inaccessibles, et donc on a le langage rationnel $\Rightarrow$ le langage reconnaissable.

	\paragraph{Exemple} % (fold)
	\label{par:exemple}

	Soit l'expression régulière, $(a+ab)^*$, on va construire l'automate de l'expression régulière de manière détaillé :

	\begin{itemize}
		\item $a$ :\\
		
		\begin{center}

			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
				\tikzstyle{every state}=[draw=black,text=black]
			
				\node[state,initial]							(1)	{$q_0$};
				\node[state,accepting]			[right of=1]	(2)	{$q_1$};
		
				\path	(1)	edge					node{$a$}	(2);
		
			\end{tikzpicture}\\
			
		\end{center}

		\item $b$ :\\

		\begin{center}

			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
				\tikzstyle{every state}=[draw=black,text=black]
			
				\node[state,initial]							(1)	{$q_0'$};
				\node[state,accepting]			[right of=1]	(2)	{$q_1'$};
		
				\path	(1)	edge					node{$b$}	(2);
		
			\end{tikzpicture}\\
			
		\end{center}

		\item $ab$ :\\

		\begin{center}

			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
				\tikzstyle{every state}=[draw=black,text=black]
			
				\node[state,initial]							(1)	{$q_0$};
				\node[state]					[right of=1]	(2)	{$q_1$};
				\node[state]					[right of=2]	(3)	{$q_0'$};
				\node[state,accepting]			[right of=3]	(4)	{$q_1'$};

		
				\path	(1)	edge					node{$a$}	(2);
				\path	(2)	edge 	[bend right]	node{$b$}	(4);
				\path	(3)	edge 					node{$b$}	(4);
		
			\end{tikzpicture}\\
			
		\end{center}

		Simplification :\\

		\begin{center}

			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
				\tikzstyle{every state}=[draw=black,text=black]
			
				\node[state,initial]							(1)	{$q_0$};
				\node[state]					[right of=1]	(2)	{$q_1$};
				\node[state,accepting]			[right of=2]	(3)	{$q_1'$};

		
				\path	(1)	edge					node{$a$}	(2);
				\path	(2)	edge 					node{$b$}	(3);
		
			\end{tikzpicture}\\
			
		\end{center}


		\item $a+ab$ :\\

		\begin{center}

			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
				\tikzstyle{every state}=[draw=black,text=black]
			
				\node[state,initial]							(1)	{$q_0''$};
				\node[state,accepting]			[right of=1]	(2)	{$q_1''$};

		
				\path	(1)	edge					node{$a$}	(2);
		
			\end{tikzpicture}\\
			
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
				\tikzstyle{every state}=[draw=black,text=black]
			
				\node[state,initial]							(1)	{$q_0$};
				\node[state]					[right of=1]	(2)	{$q_1$};
				\node[state,accepting]			[right of=2]	(3)	{$q_1'$};

		
				\path	(1)	edge					node{$a$}	(2);
				\path	(2)	edge					node{$b$}	(3);

		
			\end{tikzpicture}\\

		\end{center}


		\item $(a+ab)^*$ :\\

		\begin{center}

			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
				\tikzstyle{every state}=[draw=black,text=black]
			
				\node[state,initial]			[below left of=2]	(1)	{$q$};
				\node[state]										(2)	{$q_0''$};
				\node[state,accepting]			[right of=2]		(3)	{$q_1''$};
				\node[state]					[below left of=1]	(4)	{$q_0$};
				\node[state]					[right of=4]		(5)	{$q_1$};
				\node[state,accepting]			[right of=5]		(6)	{$q_1'$};

		
				\path	(1)	edge	[left]			node{$a$}	(3)
							edge	[left]			node{$a$}	(5)
						(2)	edge					node{$a$}	(3)
						(3)	edge 	[loop above]	node{$a$}	(3)
							edge 					node{$a$}	(5)
						(4)	edge 					node{$a$}	(5)
						(5)	edge 					node{$b$}	(6)
						(6) edge					node{$a$}	(3)
						(6) edge	[bend left]		node{$a$}	(5);

		
			\end{tikzpicture}\\

		\end{center}

		Cette automate peut être simplifier de cette manière :

		\begin{center}

			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm]
				\tikzstyle{every state}=[draw=black,text=black]
			
				\node[state,initial]			[below left of=2]	(1)	{$q$};
				\node[state,accepting]			[right of=2]		(3)	{$q_1''$};
				\node[state]					[right of=4]		(5)	{$q_1$};
				\node[state,accepting]			[right of=5]		(6)	{$q_1'$};

		
				\path	(1)	edge	[left]			node{$a$}	(3)
							edge	[left]			node{$a$}	(5)
						(3)	edge 	[loop above]	node{$a$}	(3)
							edge 					node{$a$}	(5)
						(5)	edge 					node{$b$}	(6)
						(6) edge					node{$a$}	(3)
						(6) edge	[bend left]		node{$a$}	(5);

		
			\end{tikzpicture}\\

		\end{center}		

	\end{itemize}

	% paragraph exemple (end)


\end{itemize}

% paragraph preuve (end)


% section _quivalence_des_formalismes (end)


% chapter langage_relationnel (end)
